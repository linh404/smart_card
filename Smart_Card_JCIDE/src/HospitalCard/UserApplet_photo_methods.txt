    /**
     * Set photo data (chunked upload)
     * Format: [chunkIndex (2 bytes)] [totalChunks (2 bytes)] [chunkData]
     * - chunkIndex: 0-based index of this chunk
     * - totalChunks: Total number of chunks
     * - chunkData: Photo data for this chunk
     * 
     * Response: [0x00] if success
     */
    private void setPhoto(APDU apdu) {
        if (initialized != 1) {
            ISOException.throwIt((short) 0x6985);
        }

        if (!isMasterKeyValid()) {
            ISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);
        }

        byte[] buf = apdu.getBuffer();
        short offset = ISO7816.OFFSET_CDATA;

        try {
            // Parse chunk metadata
            short chunkIndex = Util.getShort(buf, offset);
            offset += 2;
            short totalChunks = Util.getShort(buf, offset);
            offset += 2;

            // Calculate chunk data length
            short dataLen = (short) (buf[ISO7816.OFFSET_LC] & 0xFF);
            short chunkDataLen = (short) (dataLen - 4); // Subtract metadata (4 bytes)

            if (chunkDataLen <= 0 || chunkDataLen > 200) {
                ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);
            }

            // If this is the first chunk, reset photo buffer
            if (chunkIndex == 0) {
                encPhotoLength = 0;
                Util.arrayFillNonAtomic(encPhoto, (short) 0, MAX_PHOTO_LENGTH, (byte) 0);
            }

            // Calculate destination offset in encPhoto
            short destOffset = (short) (chunkIndex * 200);

            // Check if we exceed MAX_PHOTO_LENGTH
            if ((short) (destOffset + chunkDataLen) > MAX_PHOTO_LENGTH) {
                ISOException.throwIt((short) 0x6A80); // Photo too large
            }

            // Copy chunk data to encPhoto
            Util.arrayCopyNonAtomic(buf, offset, encPhoto, destOffset, chunkDataLen);

            // Update total photo length
            if ((short) (destOffset + chunkDataLen) > encPhotoLength) {
                encPhotoLength = (short) (destOffset + chunkDataLen);
            }

            // If this is the last chunk, encrypt photo with MK_user
            if (chunkIndex == (short) (totalChunks - 1)) {
                // Encrypt photo in-place
                short paddedLength = (short) ((encPhotoLength + 15) / 16 * 16);
                
                // Pad to 16-byte boundary
                if (paddedLength > encPhotoLength) {
                    Util.arrayFillNonAtomic(encPhoto, encPhotoLength, 
                        (short) (paddedLength - encPhotoLength), (byte) 0);
                }

                aesKey.setKey(mkUser, (short) 0);
                aesCipher.init(aesKey, Cipher.MODE_ENCRYPT);

                // Create temp buffer for encrypted data
                byte[] tempEncPhoto = JCSystem.makeTransientByteArray(paddedLength, JCSystem.CLEAR_ON_DESELECT);
                encPhotoLength = aesCipher.doFinal(encPhoto, (short) 0, paddedLength, tempEncPhoto, (short) 0);

                // Copy back to encPhoto
                Util.arrayCopyNonAtomic(tempEncPhoto, (short) 0, encPhoto, (short) 0, encPhotoLength);
            }

            // Success response
            buf[0] = (byte) 0x00;
            apdu.setOutgoingAndSend((short) 0, (short) 1);

        } catch (CryptoException e) {
            ISOException.throwIt((short) (0x6F00 | e.getReason()));
        } catch (Exception e) {
            ISOException.throwIt((short) 0x6F00);
        }
    }

    /**
     * Get photo data
     * Response: [photoLength (2 bytes)] [encryptedPhotoData]
     */
    private void getPhoto(APDU apdu) {
        if (initialized != 1) {
            ISOException.throwIt((short) 0x6985);
        }

        if (!isMasterKeyValid()) {
            ISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);
        }

        byte[] buf = apdu.getBuffer();

        try {
            // Decrypt photo
            if (encPhotoLength == 0) {
                // No photo stored, return empty
                Util.setShort(buf, (short) 0, (short) 0);
                apdu.setOutgoingAndSend((short) 0, (short) 2);
                return;
            }

            aesKey.setKey(mkUser, (short) 0);
            aesCipher.init(aesKey, Cipher.MODE_DECRYPT);

            // Decrypt to temp buffer
            byte[] decryptedPhoto = JCSystem.makeTransientByteArray(MAX_PHOTO_LENGTH, JCSystem.CLEAR_ON_DESELECT);
            short decryptedLen = aesCipher.doFinal(encPhoto, (short) 0, encPhotoLength, decryptedPhoto, (short) 0);

            // Find actual photo length (remove padding)
            short actualLen = decryptedLen;
            for (short i = (short) (decryptedLen - 1); i >= 0; i--) {
                if (decryptedPhoto[i] != 0) {
                    actualLen = (short) (i + 1);
                    break;
                }
            }

            // Build response: [photoLength (2 bytes)] [photoData]
            short offset = 0;
            Util.setShort(buf, offset, actualLen);
            offset += 2;

            // Copy photo data (in chunks if needed, for now copy all)
            // Note: APDU buffer is limited to ~256 bytes, so we need chunking for large photos
            // For simplicity, we return up to 250 bytes. Client should call multiple times.
            short copyLen = actualLen;
            if (copyLen > 250) {
                copyLen = 250; // Max per response
            }

            Util.arrayCopyNonAtomic(decryptedPhoto, (short) 0, buf, offset, copyLen);
            offset += copyLen;

            apdu.setOutgoingAndSend((short) 0, offset);

        } catch (CryptoException e) {
            ISOException.throwIt((short) (0x6F00 | e.getReason()));
        } catch (Exception e) {
            ISOException.throwIt((short) 0x6F00);
        }
    }
}
